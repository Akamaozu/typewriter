'use strict'
/**
 * This client was automatically generated by Segment Typewriter. ** Do Not Edit **
 */
var __assign =
	(this && this.__assign) ||
	function() {
		__assign =
			Object.assign ||
			function(t) {
				for (var s, i = 1, n = arguments.length; i < n; i++) {
					s = arguments[i]
					for (var p in s)
						if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
				}
				return t
			}
		return __assign.apply(this, arguments)
	}
var __importDefault =
	(this && this.__importDefault) ||
	function(mod) {
		return mod && mod.__esModule ? mod : { default: mod }
	}
Object.defineProperty(exports, '__esModule', { value: true })
/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 *
 * You can install it with: `npm install --save-dev ajv`.
 */
var ajv_1 = __importDefault(require('ajv'))
exports.defaultValidationErrorHandler = function(message, violations) {
	var msg = JSON.stringify(
		{
			type: 'Typewriter JSON Schema Validation Error',
			description:
				'You made an analytics call (' +
				message.event +
				") using Typewriter that doesn't match the " +
				'Tracking Plan spec. Your analytics call will continue to fire in production.',
			errors: violations,
		},
		undefined,
		2
	)
	if (process.env.NODE_ENV === 'test') {
		throw new Error(msg)
	}
	console.error(msg)
	return false
}
var onViolation = exports.defaultValidationErrorHandler
var missingAnalyticsNodeError = new Error(
	"You must set an analytics-node instance:\n\n>\tconst SegmentAnalytics = require('analytics-node')\n>\tconst { setTypewriterOptions } = require('./analytics')\n>\n>\tconst analytics = new SegmentAnalytics('SEGMENT_WRITE_KEY')\n>\tsetTypewriterOptions({\n>\t\tanalytics: analytics,\n>\t})\n\nFor more information on analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/\n"
)
var analytics = function() {
	throw missingAnalyticsNodeError
}
/**
 * Update the run-time configuration of this Typewriter client.
 */
function setTypewriterOptions(options) {
	analytics = options.analytics
		? function() {
				return options.analytics
		  }
		: analytics
	onViolation = options.onViolation || onViolation
}
exports.setTypewriterOptions = setTypewriterOptions
/**
 * Validates a message against a JSON Schema using Ajv. If the message
 * is invalid, the `onViolation` handler will be called.
 * Returns true if the message should be sent on to Segment, and false otherwise.
 */
function matchesSchema(message, schema) {
	var ajv = new ajv_1.default({
		schemaId: 'auto',
		allErrors: true,
		verbose: true,
	})
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'))
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'))
	if (!ajv.validate(schema, message) && ajv.errors) {
		return onViolation(message, ajv.errors)
	}
	return true
}
/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message) {
	return __assign({}, message, {
		context: __assign({}, message.context || {}, {
			typewriter: {
				language: 'javascript',
				version: '7.0.0',
			},
		}),
	})
}
/**
 */
function I42TerribleEventName3(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: '42_--terrible==\\"event\'++name~!3',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: '42_--terrible==\\"event\'++name~!3',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.I42TerribleEventName3 = I42TerribleEventName3
/**
 */
function analyticsInstanceMissing(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Analytics Instance Missing',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Analytics Instance Missing',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.analyticsInstanceMissing = analyticsInstanceMissing
/**
 */
function analyticsInstanceMissingThrewError(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Analytics Instance Missing Threw Error',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Analytics Instance Missing Threw Error',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.analyticsInstanceMissingThrewError = analyticsInstanceMissingThrewError
/**
 */
function customViolationHandler(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Custom Violation Handler' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'regex property': {
						description: '',
						pattern: 'Lawyer Morty|Evil Morty',
						type: 'string',
					},
				},
				required: ['regex property'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Custom Violation Handler',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.customViolationHandler = customViolationHandler
/**
 */
function customViolationHandlerCalled(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Custom Violation Handler Called',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Custom Violation Handler Called',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.customViolationHandlerCalled = customViolationHandlerCalled
/**
 */
function defaultViolationHandler(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Default Violation Handler',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'regex property': {
						description: '',
						pattern: 'Lawyer Morty|Evil Morty',
						type: 'string',
					},
				},
				required: ['regex property'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Default Violation Handler',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.defaultViolationHandler = defaultViolationHandler
/**
 */
function defaultViolationHandlerCalled(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Default Violation Handler Called',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Default Violation Handler Called',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.defaultViolationHandlerCalled = defaultViolationHandlerCalled
/**
 */
function emptyEvent(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Empty Event' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Empty Event',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.emptyEvent = emptyEvent
/**
 */
function eventCollided(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Event Collided' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Event Collided',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.eventCollided = eventCollided
/**
 */
function everyNullableOptionalType(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Every Nullable Optional Type',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		properties: {
			context: {},
			properties: {
				properties: {
					'optional any': {
						description: 'Optional any property',
					},
					'optional array': {
						description: 'Optional array property',
						type: ['array', 'null'],
					},
					'optional boolean': {
						description: 'Optional boolean property',
						type: ['boolean', 'null'],
					},
					'optional int': {
						description: 'Optional integer property',
						type: ['integer', 'null'],
					},
					'optional number': {
						description: 'Optional number property',
						type: ['number', 'null'],
					},
					'optional object': {
						description: 'Optional object property',
						properties: {},
						required: [],
						type: ['object', 'null'],
					},
					'optional string': {
						description: 'Optional string property',
						type: ['string', 'null'],
					},
					'optional string with regex': {
						description: 'Optional string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: ['string', 'null'],
					},
				},
				type: 'object',
			},
			traits: {},
		},
		type: 'object',
		title: 'Every Nullable Optional Type',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.everyNullableOptionalType = everyNullableOptionalType
/**
 */
function everyNullableRequiredType(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Every Nullable Required Type',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		properties: {
			context: {},
			properties: {
				properties: {
					'required any': {
						description: 'Required any property',
					},
					'required array': {
						description: 'Required array property',
						type: ['array', 'null'],
					},
					'required boolean': {
						description: 'Required boolean property',
						type: ['boolean', 'null'],
					},
					'required int': {
						description: 'Required integer property',
						type: ['integer', 'null'],
					},
					'required number': {
						description: 'Required number property',
						type: ['number', 'null'],
					},
					'required object': {
						description: 'Required object property',
						properties: {},
						required: [],
						type: ['object', 'null'],
					},
					'required string': {
						description: 'Required string property',
						type: ['string', 'null'],
					},
					'required string with regex': {
						description: 'Required string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: ['string', 'null'],
					},
				},
				required: [
					'required any',
					'required array',
					'required boolean',
					'required int',
					'required number',
					'required object',
					'required string',
					'required string with regex',
				],
				type: 'object',
			},
			traits: {},
		},
		required: ['properties'],
		type: 'object',
		title: 'Every Nullable Required Type',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.everyNullableRequiredType = everyNullableRequiredType
/**
 */
function everyOptionalType(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Every Optional Type' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		properties: {
			context: {},
			properties: {
				properties: {
					'optional any': {
						description: 'Optional any property',
					},
					'optional array': {
						description: 'Optional array property',
						type: 'array',
					},
					'optional boolean': {
						description: 'Optional boolean property',
						type: 'boolean',
					},
					'optional int': {
						description: 'Optional integer property',
						type: 'integer',
					},
					'optional number': {
						description: 'Optional number property',
						type: 'number',
					},
					'optional object': {
						description: 'Optional object property',
						key: 'optional object',
						properties: {},
						required: [],
						type: 'object',
					},
					'optional string': {
						description: 'Optional string property',
						type: 'string',
					},
					'optional string with regex': {
						description: 'Optional string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: 'string',
					},
				},
				type: 'object',
			},
			traits: {},
		},
		type: 'object',
		title: 'Every Optional Type',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.everyOptionalType = everyOptionalType
/**
 */
function everyRequiredType(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Every Required Type' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		properties: {
			context: {},
			properties: {
				properties: {
					'required any': {
						description: 'Required any property',
					},
					'required array': {
						description: 'Required array property',
						type: 'array',
					},
					'required boolean': {
						description: 'Required boolean property',
						type: 'boolean',
					},
					'required int': {
						description: 'Required integer property',
						type: 'integer',
					},
					'required number': {
						description: 'Required number property',
						type: 'number',
					},
					'required object': {
						description: 'Required object property',
						key: 'required object',
						properties: {},
						required: [],
						type: 'object',
					},
					'required string': {
						description: 'Required string property',
						type: 'string',
					},
					'required string with regex': {
						description: 'Required string property with a regex conditional',
						pattern: 'Evil Morty|Lawyer Morty',
						type: 'string',
					},
				},
				required: [
					'required any',
					'required array',
					'required boolean',
					'required int',
					'required number',
					'required object',
					'required string',
					'required string with regex',
				],
				type: 'object',
			},
			traits: {},
		},
		required: ['properties'],
		type: 'object',
		title: 'Every Required Type',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.everyRequiredType = everyRequiredType
/**
 */
function nestedArrays(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Nested Arrays' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universeCharacters: {
						description: 'All known characters from each universe.',
						items: {
							description: '',
							items: {
								description: '',
								properties: {
									name: {
										description: "The character's name.",
										type: 'string',
									},
								},
								required: ['name'],
								type: 'object',
							},
							type: 'array',
						},
						type: 'array',
					},
				},
				required: ['universeCharacters'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Nested Arrays',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.nestedArrays = nestedArrays
/**
 */
function nestedObjects(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Nested Objects' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					garage: {
						description: '',
						properties: {
							tunnel: {
								description: '',
								properties: {
									'subterranean lab': {
										description: '',
										properties: {
											"jerry's memories": {
												description: '',
												type: 'array',
											},
											"morty's memories": {
												description: '',
												type: 'array',
											},
											"summer's contingency plan": {
												description: '',
												type: 'string',
											},
										},
										required: [],
										type: 'object',
									},
								},
								required: ['subterranean lab'],
								type: 'object',
							},
						},
						required: ['tunnel'],
						type: 'object',
					},
				},
				required: ['garage'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Nested Objects',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.nestedObjects = nestedObjects
/**
 */
function propertiesCollided(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Properties Collided' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'Property Collided': {
						description: '',
						type: 'string',
					},
					property_collided: {
						description: '',
						type: 'string',
					},
				},
				required: ['property_collided', 'Property Collided'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Properties Collided',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.propertiesCollided = propertiesCollided
/**
 */
function propertyObjectNameCollision1(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Property Object Name Collision #1',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universe: {
						description: '',
						properties: {
							name: {
								description: 'The common name of this universe.',
								type: 'string',
							},
							occupants: {
								description: 'The most important occupants in this universe.',
								items: {
									description: '',
									properties: {
										name: {
											description: 'The name of this occupant.',
											type: 'string',
										},
									},
									required: ['name'],
									type: 'object',
								},
								type: 'array',
							},
						},
						required: ['name', 'occupants'],
						type: 'object',
					},
				},
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Property Object Name Collision #1',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.propertyObjectNameCollision1 = propertyObjectNameCollision1
/**
 */
function propertyObjectNameCollision2(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, {
			event: 'Property Object Name Collision #2',
		})
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universe: {
						description: '',
						properties: {
							name: {
								description: 'The common name of this universe.',
								type: 'string',
							},
							occupants: {
								description: 'The most important occupants in this universe.',
								items: {
									description: '',
									properties: {
										name: {
											description: 'The name of this occupant.',
											type: 'string',
										},
									},
									required: ['name'],
									type: 'object',
								},
								type: 'array',
							},
						},
						required: ['name', 'occupants'],
						type: 'object',
					},
				},
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Property Object Name Collision #2',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.propertyObjectNameCollision2 = propertyObjectNameCollision2
/**
 */
function propertySanitized(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Property Sanitized' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					'0000---terrible-property-name~!3': {
						description: '',
						type: 'string',
					},
				},
				required: ['0000---terrible-property-name~!3'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Property Sanitized',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.propertySanitized = propertySanitized
/**
 */
function simpleArrayTypes(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Simple Array Types' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					any: {
						description: '',
						items: {
							description: '',
						},
						type: 'array',
					},
					boolean: {
						description: '',
						items: {
							description: '',
							type: 'boolean',
						},
						type: 'array',
					},
					integer: {
						description: '',
						items: {
							description: '',
							type: 'integer',
						},
						type: 'array',
					},
					nullable: {
						description: '',
						items: {
							description: '',
							type: ['string', 'null'],
						},
						type: 'array',
					},
					number: {
						description: '',
						items: {
							description: '',
							type: 'number',
						},
						type: 'array',
					},
					object: {
						description: '',
						items: {
							description: '',
							properties: {
								name: {
									description: '',
									type: 'string',
								},
							},
							required: [],
							type: 'object',
						},
						type: 'array',
					},
					string: {
						description: '',
						items: {
							description: '',
							type: 'string',
						},
						type: 'array',
					},
				},
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'Simple Array Types',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.simpleArrayTypes = simpleArrayTypes
/**
 */
function unionType(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'Union Type' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				properties: {
					universe_name: {
						description: '',
						type: ['string', 'null', 'integer'],
					},
				},
				required: ['universe_name'],
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		required: ['properties'],
		type: 'object',
		title: 'Union Type',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.unionType = unionType
/**
 */
function eventCollided1(message, callback) {
	var msg = withTypewriterContext(
		__assign({ properties: {} }, message, { event: 'event_collided' })
	)
	var schema = {
		$schema: 'http://json-schema.org/draft-07/schema#',
		labels: {},
		properties: {
			context: {},
			properties: {
				type: 'object',
			},
			traits: {
				type: 'object',
			},
		},
		type: 'object',
		title: 'event_collided',
	}
	if (!matchesSchema(msg, schema)) {
		return
	}
	var a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
exports.eventCollided1 = eventCollided1
