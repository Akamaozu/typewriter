/**
 *  This client was automatically generated by Segment Typewriter. ** Do Not Edit **
 */

{{#if isDevelopment}}
/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: `npm install --save-dev ajv`.
 */
import Ajv from 'ajv'
{{/if}}

/**
 * Type definitions for Segment's analytics-node.
 */
export namespace Segment {
	/** A minimal interface for Segment's analytics-node. */
	export interface AnalyticsNode {
		track: (
			message: TrackMessage<Record<string, any>>,
			callback?: Callback
		) => void
	}

	/**
	 * TrackMessage represents a message payload for an analytics `.track()` call.
	 * See: https://segment.com/docs/spec/track/
	 */
	export interface TrackMessage<PropertiesType> extends Record<string, any> {
		/** The ID for this user in your database. */
		userId: string | number
		/** An ID to associated with the user when you don’t know who they are. */
		anonymousId?: string | number
		/** A dictionary of properties for the event. */
		properties?: PropertiesType
		/**
		* A Javascript date object representing when the track took place.
		* If the track just happened, leave it out and we’ll use the server’s
		* time. If you’re importing data from the past make sure you to send
		* a timestamp.
		*/
		timestamp?: Date
		/**
		* A dictionary of extra context to attach to the call.
		* https://segment.com/docs/spec/common/#context
		*/
		context?: Context
		/**
		* A dictionary of destination names that the message should be sent to.
		* By default all destinations are enabled. 'All' is a special key that
		* applies when no key for a specific destination is found.
		* https://segment.com/docs/spec/common/#integrations
		*/
		integrations?: {
			All?: boolean
			AppsFlyer?: {
				appsFlyerId: string
			}
			[key: string]: boolean | { [key: string]: string } | undefined
		}
	}

	/**
	 * Context is a dictionary of extra information that provides useful context about a datapoint.
	 * @see {@link https://segment.com/docs/spec/common/#context}
	 */
	export interface Context extends Record<string, any> {
		active?: boolean
		app?: {
			name?: string
			version?: string
			build?: string
		}
		campaign?: {
			name?: string
			source?: string
			medium?: string
			term?: string
			content?: string
		}
		device?: {
			id?: string
			manufacturer?: string
			model?: string
			name?: string
			type?: string
			version?: string
		}
		ip?: string
		locale?: string
		location?: {
			city?: string
			country?: string
			latitude?: string
			longitude?: string
			region?: string
			speed?: string
		}
		network?: {
			bluetooth?: string
			carrier?: string
			cellular?: string
			wifi?: string
		}
		os?: {
			name?: string
			version?: string
		}
		page?: {
			hash?: string
			path?: string
			referrer?: string
			search?: string
			title?: string
			url?: string
		}
		referrer?: {
			type?: string
			name?: string
			url?: string
			link?: string
		}
		screen?: {
			density?: string
			height?: string
			width?: string
		}
		timezone?: string
		groupId?: string
		traits?: Record<string, any>
		userAgent?: string
	}

	/** The callback exposed by analytics-node. */
	export type Callback = (err: Error) => void
}

{{#each interfaces}}
{{#if description}}
/**
 * {{description}}
 */
{{/if}}
interface {{name}} {
	{{#each properties}}
	{{#if description}}
	/**
	 * {{description}}
	 */
	{{/if}}
	'{{name}}'{{#unless isRequired}}?{{/unless}}: {{type}}
	{{/each}}
}
{{/each}}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext<P>(message: Segment.TrackMessage<P>): Segment.TrackMessage<P> {
	return {
		...message,
		context: {
			...(message.context || {}),
			typewriter: {
				language: 'ts',
				version: '7.0.0',
			},
		},
	}
}

/** Helper to insert an event name into a track call. */
function withEventName<P>(message: Segment.TrackMessage<P>, eventName: string): Segment.TrackMessage<P> {
  return {
    ...message,
    event: eventName,
  }  
}

export type ValidationErrorHandler = (
	message: Segment.TrackMessage<Record<string, any>>,
	{{!-- Note: we don't want to require an import of ajv in production just for this type definition. --}}
	validationErrors: {{#if isDevelopment}}Ajv.ErrorObject{{else}}any{{/if}}[]
) => boolean

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
	/**
	 * Handler fired when if an event does not match its spec. Returns a boolean
	 * indicating if the message should still be sent to Segment. This handler
	 * does not fire in production mode, because it requires inlining the full
	 * JSON Schema spec.
	 *
	 * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
	 * if a message does not match the spec. Otherwise, errors will be logged to stderr.
	 * Also by default, invalid messages will be dropped.
	 */
	onValidationError?: ValidationErrorHandler
}

{{#if isDevelopment}}
export const defaultValidationErrorHandler: ValidationErrorHandler = (message, validationErrors) => {
	const msg = JSON.stringify({
		type: 'Typewriter JSON Schema Validation Error',
		description:
			`You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
			'Tracking Plan spec. Your analytics call will continue to fire in production.',
		errors: validationErrors,
	}, null, 2)

	if (process.env.NODE_ENV === 'test') {
		throw new Error(msg)
	}
	console.error(msg)

	return false
}
{{/if}}

/**
 * A strongly-typed wrapper around analytics-node automatically generated based on your Tracking Plan.
 */
export default class Analytics {
	private analytics: Segment.AnalyticsNode

	{{#if isDevelopment}}
	private onValidationError: ValidationErrorHandler
	{{/if}}

	/**
	 * Instantiate a wrapper around an analytics-node instance.
	 * @param {Segment.AnalyticsNode} analytics The analytics-node library to wrap
	 * @param {TypewriterOptions} [options] Optional configuration of the Typewriter client
	 * @param {function} [options.onValidationError] Error handler fired when run-time validation errors
	 *     are raised.
	 */
	public constructor(
		analytics: Segment.AnalyticsNode,
		options: TypewriterOptions = {}
	) {
		this.analytics = analytics || { track: () => null }

		{{#if isDevelopment}}
		this.onValidationError = options.onValidationError || defaultValidationErrorHandler
		{{/if}}
	}

	{{#if isDevelopment}}
	/**
	 * Validates a message against a JSON Schema using Ajv. If the message
	 * is invalid, the `onValidationError` handler will be called.
	 * Returns true if the message should be sent on to Segment, and false otherwise.
	 */
	private matchesSchema(
		message: Segment.TrackMessage<Record<string, any>>,
		schema: string
	): boolean {
		const ajv = new Ajv({ schemaId: 'auto', allErrors: true, verbose: true })
		ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'))
		ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'))

		if (!ajv.validate(schema, message) && ajv.errors) {
			return this.onValidationError(message, ajv.errors)
		}

		return true
	}
	{{/if}}

	{{#each tracks}}
	{{#if description}}
	/**
	 * {{description}}
	 */
	{{/if}}
	public {{functionName}}(
		message: Segment.TrackMessage<{{type}}>,
		callback?: Segment.Callback
	): void {
		{{#if ../isDevelopment}}
		const schema = `
{{rawJSONSchema}}
		`
		if (!this.matchesSchema(message, schema)) {
			return
		}
		{{/if}}

		this.analytics.track(
			withTypewriterContext(withEventName(message, '{{eventName}}')),
			callback
		)
	}
	{{/each}}
}
