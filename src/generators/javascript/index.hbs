/**
 * {{autogeneratedFileWarning}}
 */

{{#if isDevelopment}}
/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: `npm install --save-dev ajv`.
 */
import Ajv from 'ajv'
{{/if}}
import * as Segment from './segment'

{{#each interfaces}}
{{#if description}}
/**
 * {{description}}
 */
{{/if}}
export interface {{name}} {
	{{#each properties}}
	{{#if description}}
	/**
	 * {{description}}
	 */
	{{/if}}
	'{{name}}'{{#unless isRequired}}?{{/unless}}: {{type}}
	{{/each}}
}
{{/each}}

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
	/**
	 * Underlying analytics instance where analytics calls are forwarded on to.
	 {{#if isBrowser}}
	 * Defaults to window.analytics.
	 {{/if}}
	 */
	analytics{{#if isBrowser}}?{{/if}}: {{#if isBrowser}}Segment.AnalyticsJS{{else}}Segment.AnalyticsNode{{/if}}
	/**
	 * Handler fired when if an event does not match its spec. Returns a boolean
	 * indicating if the message should still be sent to Segment. This handler
	 * does not fire in production mode, because it requires inlining the full
	 * JSON Schema spec.
	 *
	 * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
	 * if a message does not match the spec. Otherwise, errors will be logged to stderr.
	 * Also by default, messages that generate Violations will be dropped.
	 */
	onViolation?: ViolationHandler
}

export type ViolationHandler = (
	message: {{#if isBrowser}}Record<string, any>{{else}}Segment.TrackMessage<Record<string, any>>{{/if}},
	{{!-- Swap the type definitions here so we don't want depend on ajv in production just for this type definition. --}}
	violations: {{#if isDevelopment}}Ajv.ErrorObject{{else}}any{{/if}}[]
) => boolean

{{#if isDevelopment}}
export const defaultValidationErrorHandler: ViolationHandler = (message, violations) => {
	const msg = JSON.stringify({
		type: 'Typewriter JSON Schema Validation Error',
		description:
			`You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
			'Tracking Plan spec. Your analytics call will continue to fire in production.',
		errors: violations,
	}, undefined, 2)

	{{#unless isBrowser}}
	if (process.env.NODE_ENV === 'test') {
		throw new Error(msg)
	}
	{{/unless}}
	console.error(msg)

	return false
}

let onViolation = defaultValidationErrorHandler
{{/if}}

{{#unless isBrowser}}
const missingAnalyticsNodeError = new Error(`You must set an analytics-node instance:

>	const SegmentAnalytics = require('analytics-node')
>	const { setTypewriterOptions } = require('./analytics')
>
>	const analytics = new SegmentAnalytics('SEGMENT_WRITE_KEY')
>	setTypewriterOptions({
>		analytics: analytics,
>	})

For more information on analytics-node, see: https://segment.com/docs/sources/server/node/quickstart/
`)
{{/unless}}

{{!-- We use a closure so we can lazy-resolve window.analytics in browser environments. --}}
let analytics: () => ({{#if isBrowser}}Segment.AnalyticsJS{{else}}Segment.AnalyticsNode{{/if}} | undefined) = () => {
	{{#if isBrowser}}
	return window.analytics
	{{else}}
	throw missingAnalyticsNodeError
	{{/if}}
}

/**
 * Update the run-time configuration of this Typewriter client.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
	analytics = options.analytics ? () => options.analytics{{#if isBrowser}} || window.analytics{{/if}} : analytics
	{{#if isDevelopment}}
	onViolation = options.onViolation || onViolation
	{{/if}}
}

{{#if isDevelopment}}
/**
	* Validates a message against a JSON Schema using Ajv. If the message
	* is invalid, the `onViolation` handler will be called.
	* Returns true if the message should be sent on to Segment, and false otherwise.
	*/
function matchesSchema(
	message: {{#if isBrowser}}Record<string, any>{{else}}Segment.TrackMessage<Record<string, any>>{{/if}},
	schema: object
): boolean {
	const ajv = new Ajv({ schemaId: 'auto', allErrors: true, verbose: true })
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'))
	ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'))

	if (!ajv.validate(schema, message) && ajv.errors) {
		return onViolation(message, ajv.errors)
	}

	return true
}
{{/if}}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext{{#unless isBrowser}}<P, T extends Segment.TrackMessage<P>>{{/unless}}(message: {{#if isBrowser}}Segment.Options = {}{{else}}T{{/if}}): {{#if isBrowser}}Segment.Options{{else}}T{{/if}} {
	return {
		...message,
		context: {
			...(message.context || {}),
			typewriter: {
				language: '{{language}}',
				version: '{{typewriterVersion}}',
			},
		},
	}
}

{{#each tracks}}
{{#if hasDocumentation}}
/**
 {{#if description}}
 * {{description}}
 {{/if}}
 {{#if interface}}
 * @param {object} props - The analytics properties that will be sent to Segment.
 {{#each interface.properties}}
 * @param {{type}} {{#unless isRequired}}[{{/unless}}props.{{name}}{{#unless isRequired}}]{{/unless}} - {{description}}
	{{/each}}
 {{/if}}
 */
{{/if}}
{{#if ../isBrowser}}
export function {{functionName}}(
	props{{#if isPropertiesOptional}}?{{/if}}: {{type}},
	options?: Segment.Options,
	callback?: Segment.Callback
): void {
	{{#if ../isDevelopment}}
	const schema = {{rawJSONSchema}}
	const message = {
		event: '{{eventName}}',
		properties: props || {},
		options,
	}
	if (!matchesSchema(message, schema)) {
		return
	}
	{{/if}}

	const a = analytics()
	if (a) {
		a.track(
			'{{eventName}}',
			props || {},
			withTypewriterContext(options),
			callback
		)
	}
}
{{else}}
export function {{functionName}}(
	message: Segment.TrackMessage<{{type}}>,
	callback?: Segment.Callback
): void {
	const msg = withTypewriterContext({
		properties: {},
		...message,
		event: '{{eventName}}'
	})

	{{#if ../isDevelopment}}
	const schema = {{rawJSONSchema}}	
	if (!matchesSchema(msg, schema)) {
		return
	}
	{{/if}}

	const a = analytics()
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
}
{{/if}}
{{/each}}
