import React from 'react'
import {
	getToken,
	resolveRelativePath,
	Config,
	TrackingPlanConfig,
	verifyDirectoryExists,
} from '../../config'
import { Text, Color } from 'ink'
import Link from 'ink-link'
import { JSONSchema7 } from 'json-schema'
import * as fs from 'fs'
import { promisify } from 'util'
import {
	fetchTrackingPlan,
	loadTrackingPlan,
	writeTrackingPlan,
	SegmentAPI,
	TRACKING_PLAN_FILENAME,
	computeDelta,
} from '../../api'
import { gen, RawTrackingPlan } from '../../../generators/gen'
import { SEGMENT_AUTOGENERATED_FILE_WARNING } from '../../../templates'
import { join } from 'path'
import * as childProcess from 'child_process'
import { version } from '../../../../package.json'

const readFile = promisify(fs.readFile)
const readdir = promisify(fs.readdir)
const writeFile = promisify(fs.writeFile)
const unlink = promisify(fs.unlink)
const exec = promisify(childProcess.exec)

export interface GeneratorState {
	steps: {
		loadPlan: StepState
		clearFiles: StepState
		generateClient: StepState
		afterScript: StepState
	}
}

export interface StepState {
	running: boolean
	done: boolean
	skipping: boolean
	notes: {
		// Default: note
		type?: 'warning' | 'note'
		// Supply a key if text is a JSX.Element
		key?: string
		text: string | JSX.Element
	}[]
}

export function getInitialState(config: Config): GeneratorState {
	return {
		steps: {
			loadPlan: {
				running: false,
				done: false,
				skipping: false,
				notes: [],
			},
			clearFiles: {
				running: false,
				done: false,
				skipping: false,
				notes: [],
			},
			generateClient: {
				running: false,
				done: false,
				skipping: false,
				notes: [],
			},
			afterScript: {
				running: false,
				done: false,
				skipping: !config.scripts || !config.scripts.after,
				notes: [],
			},
		},
	}
}

export async function* run(
	configPath: string | undefined,
	config: Config,
	trackingPlanConfig: TrackingPlanConfig,
	genOptions: { production: boolean; update: boolean }
) {
	const state = getInitialState(config)

	// Step 1: Load a Tracking Plan, either from the API or from the `plan.json` file.
	let step = state.steps.loadPlan
	step.running = true
	yield state
	const previousSegmentTrackingPlan = await loadTrackingPlan(configPath, trackingPlanConfig)
	let segmentTrackingPlan: SegmentAPI.TrackingPlan
	if (genOptions.update) {
		step.notes.push({
			text: 'Pulling most recent version from Segment',
		})
		yield state
		// TODO: support fine-grained event updates, by event name and by label.
		// For now, we will just support updating the full tracking plan.
		const token = await getToken(config)
		if (!token) {
			step.notes.push({
				type: 'warning',
				key: 'empty-token',
				text: (
					<Text>
						Unable to find a {''}
						<Link url="https://segment.com/docs/protocols/typewriter/#api-token-configuration">
							Segment API token
						</Link>
						, using cache instead
					</Text>
				),
			})
			// Use the cache instead:
			segmentTrackingPlan = previousSegmentTrackingPlan
		} else {
			try {
				segmentTrackingPlan = await fetchTrackingPlan({
					id: trackingPlanConfig.id,
					workspaceSlug: trackingPlanConfig.workspaceSlug,
					token,
				})

				await writeTrackingPlan(configPath, segmentTrackingPlan, trackingPlanConfig)
			} catch (err) {
				// TODO: more reliable network connection detection
				console.error(err)
				step.notes.push({
					type: 'warning',
					text: 'API request failed, using cache',
				})
				yield state
				// Use the cache instead:
				segmentTrackingPlan = previousSegmentTrackingPlan
			}
		}
	} else {
		step.notes.push({
			text: `Loading from ${trackingPlanConfig.path + '/' + TRACKING_PLAN_FILENAME}`,
		})
		yield state
		segmentTrackingPlan = previousSegmentTrackingPlan
	}
	step.notes.push({
		key: 'which-tracking-plan',
		text: (
			<Text>
				Using {''}
				<Link
					url={`https://app.segment.com/${
						trackingPlanConfig.workspaceSlug
					}/protocols/tracking-plans/${trackingPlanConfig.id}`}
				>
					{segmentTrackingPlan.display_name}
				</Link>
			</Text>
		),
	})
	yield state

	if (genOptions.update) {
		const deltas = computeDelta(previousSegmentTrackingPlan, segmentTrackingPlan)
		step.notes.push({
			key: 'changes',
			text:
				deltas.added === 0 && deltas.modified === 0 && deltas.removed === 0 ? (
					'No changes found'
				) : (
					<Text>
						<Color grey={deltas.added === 0} green={deltas.added > 0}>
							{deltas.added} added
						</Color>
						,{' '}
						<Color grey={deltas.modified === 0} yellow={deltas.modified > 0}>
							{deltas.modified} modified
						</Color>
						,{' '}
						<Color grey={deltas.removed === 0} red={deltas.removed > 0}>
							{deltas.removed} removed
						</Color>
					</Text>
				),
		})
		yield state
	}

	const trackingPlan: RawTrackingPlan = {
		trackCalls: segmentTrackingPlan.rules.events
			// Typewriter doesn't yet support event versioning. For now, we just choose the most recent version.
			.filter(e =>
				segmentTrackingPlan.rules.events.every(e2 => e.name !== e2.name || e.version >= e2.version)
			)
			.map<JSONSchema7>(e => ({
				...e.rules,
				title: e.name,
				description: e.description,
			})),
	}
	step.running = false
	step.done = true
	yield state

	// Step 2. Remove any previously generated files from the configured path.
	// We identify which files to clear using the `SEGMENT_AUTOGENERATED_FILE_WARNING` at the
	// top of every file.
	step = state.steps.clearFiles
	step.running = true
	yield state
	const path = resolveRelativePath(configPath, trackingPlanConfig.path)
	await verifyDirectoryExists(path)
	await clearFolder(path)
	step.running = false
	step.done = true
	yield state

	// Step 3: Generate the client and write it to the user's file system.
	step = state.steps.generateClient
	step.running = true
	step.notes.push({
		text: `Building for ${genOptions.production ? 'production' : 'development'}`,
	})
	step.notes.push({
		text: `Writing to ${trackingPlanConfig.path}`,
	})
	yield state
	const files = await gen(trackingPlan, {
		client: config.client,
		typewriterVersion: version,
		isDevelopment: !genOptions.production,
	})
	for (var file of files) {
		const path = resolveRelativePath(configPath, trackingPlanConfig.path, file.path)
		await verifyDirectoryExists(path, 'file')
		await writeFile(path, file.contents, {
			encoding: 'utf-8',
		})
	}
	step.running = false
	step.done = true
	yield state

	// Step 4: Optionally run the user's scripts.after script, if one was supplied.
	step = state.steps.afterScript
	if (!step.skipping) {
		step.running = true
		yield state
		if (config.scripts && config.scripts.after) {
			step.notes.push({
				text: config.scripts.after,
			})
			yield state
			await exec(config.scripts.after).catch(err => {
				step.notes.push({
					type: 'warning',
					text: String(err),
				})
			})
		}
		step.running = false
		step.done = true
		yield state
	}
}

// clearFolder removes all typewriter-generated files from the specified folder
// excluding plan.json.
// It uses a simple heuristic to avoid accidentally clobbering a user's files --
// it only clears files with the "this file was autogenerated by Typewriter" warning.
// Therefore, all generators need to output that warning in a comment in the first few
// lines of every generated file.
async function clearFolder(path: string): Promise<void> {
	const fileNames = await readdir(path, 'utf-8')
	for (let fileName of fileNames) {
		const fullPath = join(path, fileName)
		try {
			const contents = await readFile(fullPath, 'utf-8')
			if (contents.includes(SEGMENT_AUTOGENERATED_FILE_WARNING)) {
				await unlink(fullPath)
			}
		} catch (err) {
			// Note: none of our generators produce folders, but if we ever do, then we'll need to
			// update this logic to handle recursively traversing directores.
			// In the mean time, protect against
			if (err.code !== 'EISDIR') {
				await clearFolder(fullPath)
			}
		}
	}
}
