import { setConfig, resolveRelativePath, getToken, assertHasToken, storeToken } from './config'
import { JSONSchema7 } from 'json-schema'
import * as fs from 'fs'
import { promisify } from 'util'
import { fetchTrackingPlan, fetchWorkspaces, isValidToken, fetchAllTrackingPlans } from './api'
import prompts from 'prompts'
import { Arguments, Config } from './types'
import { writeTrackingPlan, loadTrackingPlan } from './trackingplans'
import { gen } from '../generators/gen'
import { RawTrackingPlan } from '../generators/gen'
import { Options, SDK, Language, JavaScriptOptions } from '../generators/options'
import { SEGMENT_AUTOGENERATED_FILE_WARNING } from '../templates'
import { join } from 'path'
import { assertConfig } from './config'

const readFile = promisify(fs.readFile)
const readdir = promisify(fs.readdir)
const writeFile = promisify(fs.writeFile)
const unlink = promisify(fs.unlink)

export async function init(args: Arguments, cfg: Config | undefined) {
	// If a user ctrl-c's a prompt, we should return early.
	let hasExited = false
	const promptOptions: prompts.Options = {
		onCancel: () => {
			hasExited = true
		},
	}

	// Set the config.client.sdk value.
	const sdkChoices = [
		{ title: 'analytics.js', value: 'analytics.js' },
		{ title: 'analytics-node', value: 'analytics-node' },
		{ title: 'analytics-ios', value: 'analytics-ios' },
		{ title: 'analytics-android', value: 'analytics-android', disabled: true },
	]
	const defaultSDK = cfg && sdkChoices.findIndex(({ value }) => value === cfg.client.sdk)
	const { sdk } = await prompts(
		{
			type: 'select',
			message: 'What SDK should the Typewriter client use?',
			name: 'sdk',
			choices: sdkChoices,
			initial: defaultSDK,
		},
		promptOptions
	)
	if (hasExited) {
		return
	}

	// Set the config.client.language value, depending on the SDK option selected.
	const languageChoices = []
	let defaultChoice = undefined
	if (sdk === SDK.WEB || sdk === SDK.NODE) {
		languageChoices.push(
			{ title: 'JavaScript', value: 'javascript' },
			{ title: 'TypeScript', value: 'typescript' }
		)
	} else if (sdk === SDK.IOS) {
		languageChoices.push(
			{ title: 'Swift', value: 'swift' },
			{ title: 'Objective-C', value: 'objective-c' }
		)
	}
	defaultChoice = cfg && languageChoices.findIndex(({ value }) => value === cfg.client.language)

	const { language } = await prompts(
		{
			type: 'select',
			message: 'What language should the Typewriter client be generated in?',
			name: 'language',
			choices: languageChoices,
			initial: defaultChoice,
		},
		promptOptions
	)
	if (hasExited) {
		return
	}

	// Request a path to write this Tracking Plan's client into.
	const { path } = await prompts(
		{
			type: 'text',
			message: 'What directory should Typewriter write this client into?',
			name: 'path',
			initial: cfg && cfg.trackingPlans.length > 0 ? cfg.trackingPlans[0].path : './analytics',
		},
		promptOptions
	)
	if (hasExited) {
		return
	}

	// Fetch a Segment API Token, of one isn't already available.
	let token = await getToken(cfg)
	if (!token) {
		// Let a user paste in a copied token.
		const { providedToken } = await prompts(
			{
				type: 'password',
				message: 'Enter a Segment API Token:',
				name: 'providedToken',
				min: 1,
			},
			promptOptions
		)
		if (hasExited) {
			return
		}
		token = providedToken

		// Cache this token for future commands.
		if (token) {
			await storeToken(token)
		}
	}
	if (!token || !(await isValidToken(token))) {
		throw new Error('The provided API token is not a valid Segment token.')
	}

	// Now that we have a token, we can fetch their Tracking Plans and have the user select
	// which one to generate a Typewriter client from.
	const availableTrackingPlans = await fetchAllTrackingPlans({ token })
	if (availableTrackingPlans.length === 0) {
		console.error(`No Tracking Plans accessible from your token (${await tokenToString(token)})`)
		return
	}
	const preSelectedTrackingPlanIDs = cfg ? cfg.trackingPlans.map(tp => tp.id) : []
	const { trackingPlanName } = await prompts(
		[
			{
				type: 'autocomplete',
				message: 'Which Tracking Plan should Typewriter generate clients for?',
				name: 'trackingPlanName',
				min: 1,
				choices: availableTrackingPlans
					// Sort Tracking Plans by update time, to match the Tracking Plan list view.
					.sort((a, b) => b.update_time.getTime() - a.update_time.getTime())
					.map(tp => ({
						title: tp.display_name,
						value: tp.name,
						selected: preSelectedTrackingPlanIDs.includes(tp.name.split('/').slice(-1)[0]),
					})),
			},
		],
		promptOptions
	)
	if (hasExited) {
		return
	}
	const trackingPlan = availableTrackingPlans.find(tp => tp.name === trackingPlanName)!

	let client: Options = {
		sdk,
		language,
	}
	// Default to ES5 syntax for analytics-node in JS, since node doesn't support things
	// like ES6 modules. TypeScript transpiles for you, so we don't need it there.
	// See https://node.green
	if (sdk === SDK.NODE && language === Language.JAVASCRIPT) {
		client = client as JavaScriptOptions
		client.moduleTarget = 'CommonJS'
		client.scriptTarget = 'ES5'
	}
	const newCfg: Config = {
		client,
		trackingPlans: [
			{
				name: trackingPlan.display_name,
				id: trackingPlan.name.split('/').slice(-1)[0],
				workspaceSlug: trackingPlan.name.replace('workspaces/', '').split('/')[0],
				path,
			},
		],
	}

	await setConfig(newCfg, args.config)

	console.log("Successfully initialized Typewriter (see 'typewriter.yml')")

	// Now generate a client using the newly initialized configuration.
	console.log("Running 'npx typewriter@next' to build a typewriter client...")
	await build(args, newCfg)
}

export async function build(args: Arguments, cfg: Config | undefined) {
	await generateClients(args, cfg, { isDevelopment: true })
}

export async function prod(args: Arguments, cfg: Config | undefined) {
	await generateClients(args, cfg, { isDevelopment: false })
}

export async function token(_: Arguments, cfg: Config | undefined) {
	const token = await assertHasToken(cfg)
	console.log(token)
}

export async function update(args: Arguments, cfg: Config | undefined) {
	cfg = await assertConfig(cfg)
	const token = await assertHasToken(cfg)

	// TODO(colinking): support fine-grained event updates, by event name and by label.
	// For now, we will just support updating the full tracking plan.
	for (var config of cfg.trackingPlans) {
		const plan = await fetchTrackingPlan({
			id: config.id,
			workspaceSlug: config.workspaceSlug,
			token,
		})

		await writeTrackingPlan(args, plan, config)
	}

	console.log("Running 'npx typewriter@next' to re-build your typewriter client...")
	await build(args, cfg)
}

// Command Helpers

// tokenToString partially redacts a token and prints a list of accessible
// workspaces to provide context on the token.
async function tokenToString(token: string) {
	const workspaces = await fetchWorkspaces({ token })
	const redactedToken = token.substring(0, 10) + '...'

	return `${redactedToken} [${workspaces.map(w => w.display_name).join(', ')}]`
}

async function generateClients(
	args: Arguments,
	cfg: Config | undefined,
	{ isDevelopment }: { isDevelopment: boolean }
) {
	cfg = await assertConfig(cfg)
	for (var config of cfg.trackingPlans) {
		// Before generating the client, first clear any previously generated client files.
		await clearFolder(await resolveRelativePath(args, 'directory', config.path))

		const segmentTrackingPlan = await loadTrackingPlan(args, config)
		const trackingPlan: RawTrackingPlan = {
			trackCalls: segmentTrackingPlan.rules.events.map<JSONSchema7>(e => ({
				...e.rules,
				title: e.name,
				description: e.description,
			})),
		}

		// Generate a client and write its files out to the specified path.
		const files = await gen(trackingPlan, {
			...cfg,
			// TODO: fetch from package.json
			typewriterVersion: '7.0.0',
			isDevelopment,
		})
		for (var file of files) {
			const path = await resolveRelativePath(args, 'file', config.path, file.path)
			await writeFile(path, file.contents, {
				encoding: 'utf-8',
			})
		}
	}
}

// clearFolder removes all typewriter-generated files from the specified folder
// excluding plan.json.
// It uses a simple heuristic to avoid accidentally clobbering a user's files --
// it only clears files with the "this file was autogenerated by Typewriter" warning.
// Therefore, all generators need to output that warning in a comment in the first few
// lines of every generated file.
// Note: none of our generators produce folders, but if we ever do, then we'll need to
// update this logic to handle recursively traversing directores.
async function clearFolder(path: string): Promise<void> {
	const fileNames = await readdir(path, 'utf-8')
	for (let fileName of fileNames) {
		const fullPath = join(path, fileName)
		const contents = await readFile(fullPath, 'utf-8')
		if (contents.includes(SEGMENT_AUTOGENERATED_FILE_WARNING)) {
			await unlink(fullPath)
		}
	}
}
